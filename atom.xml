<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[screaming.org]]></title>
  <link href="http://pohl.github.io/atom.xml" rel="self"/>
  <link href="http://pohl.github.io/"/>
  <updated>2014-09-09T07:55:17-05:00</updated>
  <id>http://pohl.github.io/</id>
  <author>
    <name><![CDATA[Pohl Longsine]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Let's Build a Browser Engine in Swift, Part 3]]></title>
    <link href="http://pohl.github.io/blog/2014/09/09/toy-layout-engine-3/"/>
    <updated>2014-09-09T06:48:21-05:00</updated>
    <id>http://pohl.github.io/blog/2014/09/09/toy-layout-engine-3</id>
    <content type="html"><![CDATA[<p>This is the third installment in a <a href="http://www.screaming.org/blog/categories/crow/">series</a> that parallels <a href="http://limpet.net/mbrubeck/">Matt Brubeck&rsquo;s</a> guided tour through making a browser engine so simplistic that its design can be captured in a handful of blog entries. The <a href="http://www.screaming.org/blog/2014/08/15/lets-build-a-browser-engine-in-swift/">first entry</a> offered a minimal set of types for a document object model. The <a href="http://www.screaming.org/blog/2014/08/22/toy-layout-engine-2/">second entry</a> described a basic parser that could reify that model from an HTML document. This entry repeats those two exercises for a different kind of document that browsers must understand: a <a href="http://en.wikipedia.org/wiki/Cascading_Style_Sheets">cascading style sheet</a>.</p>

<p>As usual, you should read <a href="http://limpet.net/mbrubeck/2014/08/13/toy-layout-engine-3-css.html">our fearless leader&rsquo;s post</a> prior to reading this one. After all, Matt works for Mozilla, while I&rsquo;m just someone who thought it would be fun to <a href="https://github.com/pohl/Crow">follow along</a>.</p>

<h2>CSS Model</h2>

<p><a href="http://www.w3.org/TR/CSS2/">Cascading Style Sheets (CSS)</a> is a declarative language specific to the domain of associating elements in some markup language with properties describing their format and layout. The structure of the language, at the largest scale, is just a list of rules.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public struct Stylesheet {
</span><span class='line'>    public let rules: [Rule]
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>One rule might look like this:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>body { background-color: #4a525a; }
</span></code></pre></td></tr></table></div></figure>


<p>Each <em>rule</em> is made of a comma-delimited list of <em>selectors</em> followed by a <em>declaration block</em>, the former being everything prior to the opening curly-brace, and the latter being a semicolon-delimited list of <em>declarations</em> bounded by curly-braces.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public struct Rule {
</span><span class='line'>    public let selectors: [Selector]
</span><span class='line'>    public let declarations: [Declaration]
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>We&rsquo;re going to confine ourselves to a well-trafficked subset of selector syntax, but we&rsquo;re going to allow a place to extend our model later should we decide to support selector combinators or selector namespaces. We&rsquo;ll do this by defining an <code>enum</code> – which, for now, will only have one case:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public enum Selector {
</span><span class='line'>    case Simple(SimpleSelector)
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>That case encompasses the familiar:</p>

<blockquote><p>&hellip;a simple selector can include a tag name, an ID prefixed by &lsquo;#&rsquo;, any number of class names prefixed by &lsquo;.&rsquo;, or some combination of the above.</p></blockquote>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public struct SimpleSelector {
</span><span class='line'>    public var tagName: String?
</span><span class='line'>    public var id: String?
</span><span class='line'>    public var classes: [String]
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>Each declaration in the semicolon-delimited list is just a name/value pair separated by a colon.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public struct Declaration {
</span><span class='line'>    public let name: String
</span><span class='line'>    public let value: Value
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>The values in these pairs, however, can take many forms. Again, we aim to ignore the devil hiding in the mountain of details so we limit ourselves to simple keywords, pixel-unit values, and colors.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public enum Value {
</span><span class='line'>    case Keyword(String)
</span><span class='line'>    case Length(Float, Unit)
</span><span class='line'>    case Color(UInt8, UInt8, UInt8, UInt8) // RGBA
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>public enum Unit {
</span><span class='line'>    case Px
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>Now that we have some types we can use to represent simple stylesheets, we move on to making a corresponding parser.</p>

<h2>CSS Parser</h2>

<p>Our quick-and-dirty parser implementation looks very much like the HTML parser in the last post, with a handlful of functions that invoke the <code>consumeWhile()</code> function with various predicates.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// Parse a property name or keyword.
</span><span class='line'>mutating func parseIdentifier() -&gt; String {
</span><span class='line'>    return self.consumeWhile(validIdentifierChar)
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>This is a good place to mention a little bit of follow-up from the last post. Recall that I ran into a little hurdle when I tried to test character-set membership using a Swift <code>Character</code> type, and ended up creating bridging the gap through <code>NSString</code>, which was a bit of a kluge. It turns out that this hack only became necessary because I was insisting on using the old <code>NSCharacterSet</code> class. If I had given up on that API, I might have ended up with some predicates that looked a lot more like their Rust counterparts in the <a href="https://github.com/mbrubeck/robinson">Robinson</a> code.</p>

<p>After playing around in a Swift Playground, I figured out that ranges of Characters actually do work after all. I just had to use <code>...</code> instead of <code>..</code>, and replace Rust&rsquo;s <code>|</code> operator with commas.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func validIdentifierChar(c: Character) -&gt; Bool {
</span><span class='line'>    switch c {
</span><span class='line'>    case "a"..."z", "A"..."Z", "0"..."9", "-", "_": return true // TODO: Include U+00A0 and higher.
</span><span class='line'>    case _: return false
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>That said, I would have had to write some extra code either way, because Matt&rsquo;s code gets to lean on Rust&rsquo;s <code>std::char::is_whitespace</code> method. Swift&rsquo;s <code>Character</code> doesn&rsquo;t have such a method (yet) so either I create one of my own – similar to the <code>validIdentifierChar()</code> method above – or I set up the Rube Goldberg bridge to <code>NSCharacterSet</code>.</p>

<p>Now we can look at our method to parse a <code>SimpleSelector</code>. You may have noticed that I declared its fields as <code>var</code> above. There was a reason for that: the way the following method imitates its Rust counterpart requires it. Notice how we allocate the <code>SimpleSelector</code> before entering the loop, and mutate its fields as we encounter characters in the loop. If I really wanted to keep my structure immutable, I could have created more local variables and constructed the <code>SimpleSelector</code> at the end of the loop.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// Parse one simple selector, e.g.: `type#id.class1.class2.class3`
</span><span class='line'>mutating func parseSimpleSelector() -&gt; SimpleSelector {
</span><span class='line'>    var selector = SimpleSelector(tagName: nil, id: nil, classes: [])
</span><span class='line'>    outerLoop: while !self.eof() {
</span><span class='line'>        switch self.nextCharacter() {
</span><span class='line'>        case "#":
</span><span class='line'>            self.consumeCharacter()
</span><span class='line'>            selector.id = self.parseIdentifier()
</span><span class='line'>        case ".":
</span><span class='line'>            self.consumeCharacter()
</span><span class='line'>            selector.classes.append(self.parseIdentifier())
</span><span class='line'>        case "*":
</span><span class='line'>            // universal selector
</span><span class='line'>            self.consumeCharacter()
</span><span class='line'>        case let c where validIdentifierChar(c):
</span><span class='line'>            selector.tagName = self.parseIdentifier()
</span><span class='line'>        case _:
</span><span class='line'>            break outerLoop
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>    return selector;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>The type alias for the <code>Specificity</code> tuple looks very much like the equivalent in Robinson. I was tempted here to use Swift&rsquo;s feature that allows us to name the three fields of the tuple. There were a few moments where I had to keep reminding myself which field represented which part of the selector, so I probably should have leveraged that feature.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public typealias Specificity = (Int, Int, Int)</span></code></pre></td></tr></table></div></figure>


<p>I wrote the function that computes the specificity of a selector turned out as a Swift &ldquo;computed property&rdquo;.
There was no particular reason for that, and I&rsquo;m not yet sure when one should or should not do that.</p>

<p>There is more to say about how this compares to the equivalent method in Robinson, though. Notice how Rust&rsquo;s <code>std::option</code> is an actual collection with an iterator that you can query for cardinality. This is something you cannot yet do with Swift&rsquo;s <code>Optional</code>. I don&rsquo;t mind having to substitute some ternary expressions here, but I do like the Rust way.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>extension Selector {
</span><span class='line'>    public var specificity: Specificity {
</span><span class='line'>        switch self {
</span><span class='line'>        case .Simple(let simple):
</span><span class='line'>            let a = simple.id == nil ? 0 : 1
</span><span class='line'>            let b = simple.classes.count
</span><span class='line'>            let c = simple.tagName == nil ? 0 : 1
</span><span class='line'>            return Specificity(a, b, c)
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>


<p>Here is the last pair of methods mentioned in Matt&rsquo;s post. As with most of what we have seen so far, the Swift versions looks very much like the Rust counterparts. The most obvious difference here is that the <code>break</code> statement requires an <code>outerLoop</code> label to signify that it is the <code>while</code> loop that we want to break out of, and not the <code>switch</code>. Rust doesn&rsquo;t have this ambiguity. I suspect the reason can be traced back to Rust&rsquo;s expression-oriented nature. I bet that Swift will likely be the last major new language to go down the statement-oriented path. If I could have only one wish to make Swift better, I would wish that it had taken the high road.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// Parse a rule set: `&lt;selectors&gt; { &lt;declarations&gt; }`.
</span><span class='line'>mutating func parseRule() -&gt; Rule {
</span><span class='line'>    return Rule(selectors: self.parseSelectors(), declarations: self.parseDeclarations())
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>// Parse a comma-separated list of selectors.
</span><span class='line'>mutating func parseSelectors() -&gt; [Selector] {
</span><span class='line'>    var selectors: [Selector] = []
</span><span class='line'>    outerLoop: while true {
</span><span class='line'>        selectors.append(.Simple(self.parseSimpleSelector()))
</span><span class='line'>        self.consumeWhitespace()
</span><span class='line'>        let c = self.nextCharacter()
</span><span class='line'>        switch c {
</span><span class='line'>            case ",":
</span><span class='line'>                self.consumeCharacter()
</span><span class='line'>                self.consumeWhitespace()
</span><span class='line'>            case "{":
</span><span class='line'>                break outerLoop
</span><span class='line'>            case _:
</span><span class='line'>                assert(false, "Unexpected character \(c) in selector list")
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>    // Return selectors with highest specificity first, for use in matching.
</span><span class='line'>    selectors.sort {
</span><span class='line'>        $0 &gt; $1
</span><span class='line'>    }
</span><span class='line'>    return selectors
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>


<p>Finally, I would like to point out that the closure given to the <code>sort</code> method above works because I overloaded the <code>&gt;</code> operator. This is another thing that Rust gives for free. Since every slot in our <code>Specificity</code> tuple is occupied by something that implements <code>Ord</code>, the entire tuple automatically implements <code>Ord</code>, and can therefore be compared in a manner somewhat similar to how <a href="http://stackoverflow.com/questions/5292303/python-tuple-comparison/5292332#5292332">Python allows</a>. In the absence of such linguistic luxury, I implemented this:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func &gt; (lhs:Specificity, rhs:Specificity) -&gt; Bool {
</span><span class='line'>    if lhs.0 == rhs.0 {
</span><span class='line'>        if lhs.1 == rhs.1 {
</span><span class='line'>            return lhs.2 &gt; rhs.2
</span><span class='line'>        } else {
</span><span class='line'>            return lhs.1 &gt; rhs.1
</span><span class='line'>        }
</span><span class='line'>    } else {
</span><span class='line'>        return lhs.0 &gt; rhs.0
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>func &gt; (lhs: Selector, rhs: Selector) -&gt; Bool {
</span><span class='line'>    return lhs.specificity &gt; rhs.specificity
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>In the next post, we will take up the two proton packs we have built and ignore Dr. Egon Spengler&rsquo;s admonition to never cross the streams.</p>

<p>In the mean time, you may want to check out Martin Tomasi’s <a href="http://www.wambo.at:8080/GyrosOfWar/browserino/tree/master">project</a>, which is following this same exercise, but is implemented in Java.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Let's Build a Browser Engine in Swift, Part 2]]></title>
    <link href="http://pohl.github.io/blog/2014/08/22/toy-layout-engine-2/"/>
    <updated>2014-08-22T20:44:19-05:00</updated>
    <id>http://pohl.github.io/blog/2014/08/22/toy-layout-engine-2</id>
    <content type="html"><![CDATA[<p>By the end of <a href="http://screaming.org/blog/2014/08/15/lets-build-a-browser-engine-in-swift/">part one</a>
of this series we had a rudimentary document object model for representing only a tiny subset of the universe of possible HTML documents. This installment, modelled after the <a href="http://limpet.net/mbrubeck/2014/08/11/toy-layout-engine-2.html">second post</a> in Matt Brubeck&rsquo;s series, implements an equally modest HTML parser that will build instances of the model we defined last time.</p>

<h2>The HTML Parser</h2>

<p>Our parser, just like our model, directly mirrors the design of Matt&rsquo;s implementation in Rust. The primary
challenge is just one of translating between two languages. Open <a href="http://limpet.net/mbrubeck/2014/08/11/toy-layout-engine-2.html">Matt&rsquo;s post</a> in
another browser window to compare the Swift code below to the original Rust.</p>

<p>The first thing we need is a type to represent parsing state: the input string and the index of the
next unprocessed character. Immediately this gets us into the differences between how Rust and Swift
implement strings. Both languages need to handle the complexity of Unicode while being as efficient and
safe as possible. In Rust our index was a <code>uint</code> that indexes into an <code>&amp;str</code> slice created from the <code>String</code>.  In Swift, we
can index directly into the String, but our index type is a <code>String.Index</code> struct with a <code>succesor()</code> method that handles
the complexity of stepping from character to character without accidentally stepping into the middle of one that has a multi-byte representation.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct Parser {
</span><span class='line'>    var pos: String.Index
</span><span class='line'>    let input: String
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>Notice that since the input string doesn&rsquo;t change, we can use a <code>let</code> binding for it. The index, on the other hand, changes as we parse the document, which requires us to use <code>var</code>. Now that
we have this type defined, we can implement a few foundational methods.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>extension Parser {
</span><span class='line'>
</span><span class='line'>    // Read the current Character without consuming it.
</span><span class='line'>    func nextCharacter() -&gt; Character {
</span><span class='line'>        return input[self.pos]
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>    // Does the current input start with the given string?
</span><span class='line'>    func startsWith(s: String) -&gt; Bool {
</span><span class='line'>        return self.input.substringFromIndex(self.pos).hasPrefix(s)
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>    // Return true if all input is consumed.
</span><span class='line'>    func eof() -&gt; Bool {
</span><span class='line'>        return self.pos &gt;= self.input.endIndex
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    // ...
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>These methods look very much like the Rust equivalents. The most obvious difference is that the references to <code>self</code> are explicitly declared in Rust but are implicit in Swift.</p>

<p>Next we come to the place where the <code>successor()</code> method of <code>String.Index</code> allows us to safely advance to the next Unicode <code>Character</code>. This is the first method that mutates parsing state. Notice how the <code>&amp;mut self</code> in the Rust implementation is replaced by the <code>mutating</code> keyword in Swift.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// Return the current Character, and advance self.pos to the next Character.
</span><span class='line'>mutating func consumeCharacter() -&gt; Character {
</span><span class='line'>    let result = input[self.pos]
</span><span class='line'>    self.pos = self.pos.successor()
</span><span class='line'>    return result
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>The next method is the heart of the parser. It consumes characters one by one for as long as the predicate function evaluates to <code>true</code>.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// Consume Character until `test` returns false.
</span><span class='line'>mutating func consumeWhile(test: Character -&gt; Bool) -&gt; String {
</span><span class='line'>    var result = ""
</span><span class='line'>    while !self.eof() && test(self.nextCharacter()) {
</span><span class='line'>        result.append(consumeCharacter())
</span><span class='line'>    }
</span><span class='line'>    return result
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>At this point in Matt&rsquo;s post, we would be defining a pair of methods using the one above. Both of these methods, however, want to pass predicates that test character set membership.  This is something that required a little gymnastics due to an apparent impedence mismatch between the native Swift <code>Character</code> type and the <code>NSCharacterSet</code> class, whose <code>characterIsMember</code> method requires a <code>unichar</code>. I was unable to find an easy way to convert one to another directly. Fortunately, <code>NSString</code> was a useful stepping stone between the two.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>extension Character {
</span><span class='line'>
</span><span class='line'>    func isMemberOf(set: NSCharacterSet) -&gt; Bool {
</span><span class='line'>        let bridgedCharacter = (String(self) as NSString).characterAtIndex(0)
</span><span class='line'>        return set.characterIsMember(bridgedCharacter)
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>Using this workaround we can implement the desired methods:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// Consume and discard zero or more whitespace Character.
</span><span class='line'>mutating func consumeWhitespace() {
</span><span class='line'>    self.consumeWhile( {$0.isMemberOf(NSCharacterSet.whitespaceCharacterSet()) })
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>// Parse a tag or attribute name.
</span><span class='line'>mutating func parseTagName() -&gt; String {
</span><span class='line'>    return self.consumeWhile( {$0.isMemberOf(NSCharacterSet.alphanumericCharacterSet()) })
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>Now we finally get to finally write some functions that produce nodes in our object model.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// Parse a single node.
</span><span class='line'>mutating func parseNode() -&gt; Node {
</span><span class='line'>    switch self.nextCharacter() {
</span><span class='line'>        case "&lt;": return self.parseElement()
</span><span class='line'>        case _: return self.parseText()
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>// Parse a text node.
</span><span class='line'>mutating func parseText() -&gt; Node {
</span><span class='line'>    return Node(data: self.consumeWhile({$0 != "&lt;" }))
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>The function that produces a <code>Node</code> that represents an HTML element looks like the Rust equivalent. I like the assertions, so I kept them even though I worry that this code will fail to consume the characters in release builds. I have yet to test that. <em>(Edit: this does turn out to be a problem. Thanks to <a href="http://www.reddit.com/r/swift/comments/2eccae/lets_build_a_browser_engine_in_swift_part_2/cjzskww">/u/teequ</a> for confirming that.)</em></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// Parse a single element, including its open tag, contents, and closing tag.
</span><span class='line'>mutating func parseElement() -&gt; Node {
</span><span class='line'>    // Opening tag.
</span><span class='line'>    assert(self.consumeCharacter() == "&lt;")
</span><span class='line'>    let tagName = self.parseTagName()
</span><span class='line'>    let attrs = self.parseAttributes()
</span><span class='line'>    assert(self.consumeCharacter() == "&gt;")
</span><span class='line'>        
</span><span class='line'>    // Contents.
</span><span class='line'>    let children = self.parseNodes()
</span><span class='line'>        
</span><span class='line'>    // Closing tag.
</span><span class='line'>    assert(self.consumeCharacter() == "&lt;")
</span><span class='line'>    assert(self.consumeCharacter() == "/")
</span><span class='line'>    assert(self.parseTagName() == tagName)
</span><span class='line'>    assert(self.consumeCharacter() == "&gt;")
</span><span class='line'>        
</span><span class='line'>    return Node(name: tagName, attrs: attrs, children: children)
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>This is also a possible concern in two of the three methods for parsing HTML element attributes and values.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// Parse a single name="value" pair.
</span><span class='line'>mutating func parseAttr() -&gt; (String, String) {
</span><span class='line'>    let name = self.parseTagName()
</span><span class='line'>    assert(self.consumeCharacter() == "=")
</span><span class='line'>    let value = self.parseAttrValue()
</span><span class='line'>    return (name, value)
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>// Parse a quoted value.
</span><span class='line'>mutating func parseAttrValue() -&gt; String {
</span><span class='line'>    let openQuote = self.consumeCharacter()
</span><span class='line'>    assert(openQuote == "\"" || openQuote == "'")
</span><span class='line'>    let value = self.consumeWhile( {$0 != openQuote} )
</span><span class='line'>    assert(self.consumeCharacter() == openQuote)
</span><span class='line'>    return value
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>// Parse a list of name="value" pairs, separated by whitespace.
</span><span class='line'>mutating func parseAttributes() -&gt; AttrMap {
</span><span class='line'>    var attributes: AttrMap = [:]
</span><span class='line'>    while (true) {
</span><span class='line'>        self.consumeWhitespace()
</span><span class='line'>        if self.nextCharacter() == "&gt;" {
</span><span class='line'>            break
</span><span class='line'>        }
</span><span class='line'>        let (name, value) = self.parseAttr()
</span><span class='line'>        attributes[name] = value
</span><span class='line'>    }
</span><span class='line'>    return attributes
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>Before we can write the top-level method that parses an entire document, we need the method that parses a set of sibling nodes.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// Parse a sequence of sibling nodes.
</span><span class='line'>mutating func parseNodes() -&gt; [Node] {
</span><span class='line'>    var nodes: [Node] = []
</span><span class='line'>    while (true) {
</span><span class='line'>        self.consumeWhitespace()
</span><span class='line'>        if self.eof() || self.startsWith("&lt;/") {
</span><span class='line'>            break
</span><span class='line'>        }
</span><span class='line'>        nodes.append(self.parseNode())
</span><span class='line'>    }
</span><span class='line'>    return nodes
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>Using the above, we can write the final method to parse a document.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// Parse an HTML document and return the root element.
</span><span class='line'>public func parse(source: String) -&gt; Node {
</span><span class='line'>    var parser = Parser(pos: source.startIndex, input: source)
</span><span class='line'>    let nodes = parser.parseNodes()
</span><span class='line'>    // If the document contains a root element, just return it. Otherwise, create one.
</span><span class='line'>    if nodes.count == 1 {
</span><span class='line'>        return nodes[0]
</span><span class='line'>    } else {
</span><span class='line'>        return Node(name: "html", attrs: [:], children: nodes)
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>The <a href="https://github.com/pohl/Crow">Crow</a> project also contains some unit tests to exercise this, which means we have finally arrived at a place where we can pull the trigger and see something happen.</p>

<p>If you have any code review to offer, please leave a comment in <a href="http://www.reddit.com/r/swift/comments/2eccae/lets_build_a_browser_engine_in_swift_part_2/">/r/swift</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Let's Build a Browser Engine in Swift]]></title>
    <link href="http://pohl.github.io/blog/2014/08/15/lets-build-a-browser-engine-in-swift/"/>
    <updated>2014-08-15T19:01:49-05:00</updated>
    <id>http://pohl.github.io/blog/2014/08/15/lets-build-a-browser-engine-in-swift</id>
    <content type="html"><![CDATA[<p>The disembodied head of Matt Brubeck over at <a href="http://limpet.net/mbrubeck/">limpet.net</a> has been producing an excellent series of blog posts chronicling the exercise of creating a toy layout engine for a web browser. Matt works for Mozilla on <a href="http://en.wikipedia.org/wiki/Servo_(layout_engine)">Servo</a>, which is about as close to the bright center of the universe as any open source project is these days. He has taken on this exercise to bolster his own mental model of how layout engines work – so that he can more effectively contribute to Servo – and, apparently, to motivate others to share the journey.</p>

<p>Do go read <a href="http://limpet.net/mbrubeck/2014/08/08/toy-layout-engine-1.html">Matt&rsquo;s first post</a> in the series. He does a fabulous job of explaining the goal and its motivation, and of setting expectations for the scope of the effort. Even if you are not interested in doing this particular exercise, you might find that the way that he thinks about setting up the challenge will help you in other pursuits.</p>

<p>Matt has chosen <a href="http://en.wikipedia.org/wiki/Rust_(programming_language)">Rust</a> as the programming language for this exercise, largely because Servo is written in it. 2014 has been an exciting year for emerging programming languages, and Rust may be the single most exhilarating one. However, I have been on a bit of a <a href="http://en.wikipedia.org/wiki/Swift_(programming_language)">Swift</a> kick[1] as of late, so I chose to use this as an opportunity to both learn how browser sausage is made and to practice some Swift.  My own toy project is called <a href="https://github.com/pohl/Crow">Crow</a>.</p>

<p>I was going to put a litany of caveats here, but I decided to spare you. You&rsquo;re welcome.</p>

<h2>First Step: The Central Model</h2>

<p>The central data model for a browser is a tree of nodes representing the HTML document. Of course there is a <a href="http://dom.spec.whatwg.org">detailed specification</a> that spells out what a real implementation needs to be like. This is just a learning exercise, so simplicity is a higher priority than completeness.</p>

<p>This might be a good time to <a href="http://limpet.net/mbrubeck/2014/08/08/toy-layout-engine-1.html">open Matt&rsquo;s article</a> in another browser window so you can compare his Rust implementation to the Swift below.</p>

<p>First we need a <code>Node</code> type so we can build the DOM tree. I&rsquo;m going to try to use <code>let</code> bindings where I can because I have grown to appreciate immutability wherever I can get it. Each node has a <code>NodeType</code>, and can also have any number of children.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public struct Node {
</span><span class='line'>    // data common to all nodes:
</span><span class='line'>    public let children: [Node]
</span><span class='line'>    // data specific to each node type:
</span><span class='line'>    public let nodeType: NodeType
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>Just like Matt&rsquo;s toy project, the <code>NodeType</code> is represented as an <code>enum</code>. There are two possible cases here: either the node represents an HTML element concomitant with tag name and a set of attributes, or it represents a string of characters between HTML tags.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public enum NodeType {
</span><span class='line'>    case Element(ElementData)
</span><span class='line'>    case Text(String)
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>When a <code>NodeType</code> represents an HTML element, it needs a data structure to hold the tag name and the attributes. The attributes are represented as a <code>Dictionary&lt;String,String&gt;</code>. Like Matt, we&rsquo;ll make a type alias for that:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public struct ElementData {
</span><span class='line'>    public let tagName: String
</span><span class='line'>    public let attributes: AttrMap
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>public typealias AttrMap = [String:String]
</span></code></pre></td></tr></table></div></figure>


<p>Finally, Matt offers a pair of <code>Node</code> constructor functions for making instances. Swift has special syntax for constructors, but it does allow us to define them separately from the <code>struct</code> in an <code>extension</code> block.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>extension Node {
</span><span class='line'>    
</span><span class='line'>    public init(data: String) {
</span><span class='line'>        self.children = []
</span><span class='line'>        self.nodeType = .Text(data)
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>    public init(name: String, attrs: AttrMap, children: [Node]) {
</span><span class='line'>        self.children = children
</span><span class='line'>        let data = ElementData(tagName: name, attributes: attrs)
</span><span class='line'>        self.nodeType = .Element(data)
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>That&rsquo;s it for the humble beginnings. Matt offers some ideas for further exercise in his post – and some links to other resources around the web – so you might want to check those out.</p>

<p>Next time I&rsquo;ll take on the simple HTML parser that builds an actual tree out of the pieces above.</p>

<hr />

<p>[1] If I had a nickel for every time my dad offered me a motivational &ldquo;swift kick&rdquo;, I&rsquo;d have several nickels.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Source Pong]]></title>
    <link href="http://pohl.github.io/blog/2014/08/09/source-pong/"/>
    <updated>2014-08-09T12:23:17-05:00</updated>
    <id>http://pohl.github.io/blog/2014/08/09/source-pong</id>
    <content type="html"><![CDATA[<p>A new season of <a href="http://layertennis.com">Layer Tennis</a> started up last night (after a four year hiatus) with two exhibition matches. Layer Tennis is a continuation of an <a href="http://everything2.com/title/Photoshop+Tennis">earlier tradition</a>, perhaps born on usenet, where two designers toss images back &amp; forth in a public forum, playing off of each other&rsquo;s work for competition and entertainment.</p>

<p>I have neither training nor inclination towards design, but I do have enough interest in the subject to drive me to compulsively refresh in anticipation of the next volley.  There is something appealing about watching two artists locked in an exchange within tight constraints while a third participant – a writer with an expert eye – provides play-by-play and color commentary.  While I was enjoying yesterday&rsquo;s &ldquo;Kleon vs. Anderson&rdquo; match I started to think about the difficulties of orchestrating similar high jinks in the world of programming.</p>

<p>There are ten volleys, and each combatant has a budget of a mere 15 minutes to deliver the next blow.  I can&rsquo;t be certain, but I imagine that the entire event is time-delayed 15 minutes to give the commentator a similar budget of time to deliver their observations to the audience. I believe that there are deliberately very few rules, other than the dimensions of the resulting image and an obligation to somehow incorporate elements of the prior image. They otherwise appear free to use any tool at their disposal: paper, found objects, knives, cameras, scanners, and of course software.</p>

<p>A naive translation into a competitive event between two programmers would keep the 15 minute constraint, and the total number of volleys. I think this would be essential, because it really does need to be an event that would play out in an afternoon.</p>

<p>The constraint that the image be a standard size could be translated into a push to a git repository. This would provide a natural way for the audience to observe the match.</p>

<p>The final rule – that the sparring partners are not allowed to ignore each other – needs no translation.  Programming does bring some interesting spin, however. You could call a function or use a structure defined by your opponent. Or, alternatively, it might be acceptable to refactor it in some way that preserves some recognizable aspect. Or maybe a volley would be returned with another program that uses some part of the prior volley as input, or produces some part of it as output.</p>

<p>I&rsquo;m tempted to say that there should be no additional rules, in order to maximize creative liberties. However, we might want to impose an additional constraint that the result be runnable. We also might want to forbid loadable resources that were not created within the time budget.</p>

<p>Perhaps the most difficult question would be whether or not to allow libraries: allowing them would open the door to leveraging vast quantities of effort expended prior to the match, and forbidding them would open a difficult question of exactly what constitutes part of a standard acceptable library – for certainly there&rsquo;s not much that can be done with exactly zero library functions. Another good question is whether we have to restrict ourselves to a single language and environment. Could a volley written as a Haskell program on FreeBSD be returned by volley in SceneKit on MacOS X that animates the tokens from the <code>.hs</code> source?</p>

<p>As I imagine what it might be like to participate in such an event, I find the most terrifying rule to be the 15-minute time limit. The results would likely be much less impressive than the images in Layer Tennis. Expect the match to look nothing like the <a href="http://en.wikipedia.org/wiki/Demo_scene">demo scene</a>. Instead, expect something closer to the <a href="http://en.wikipedia.org/wiki/Fizz_buzz">Fizz Buzz</a> end of the spectrum.</p>

<p>If I&rsquo;m playing, that is. I would love to see what some of the more talented hackers could do under such tight pressure.</p>

<p>The programming world does already have at least one game that we play out in the open, but it lacks the dueling banjos appeal of Layer Tennis. I&rsquo;m thinking of Code Golf, of course, which can produce <a href="http://codegolf.stackexchange.com/questions/35569/tweetable-mathematical-art">impressive and entertaining results</a> in a short amount of time. (Follow that last link and compare the dates of some of the answers to how long ago the question was asked.) But even here we have no idea how many hours of thought and coding happened prior to the question being asked.</p>

<p>Code Golf has a different kind of constraint: how terse can your code be? The challenge in the last paragraph, for example, is wondering what could fit within a Tweet. It doesn&rsquo;t care if my submission comes after a month of late-night hacking.</p>

<p>The programming world also has <a href="http://en.wikipedia.org/wiki/ACM_International_Collegiate_Programming_Contest">programming</a> <a href="http://www.ludumdare.com/compo/">contests</a>, but even those provide several hours for the contestants to hack. Moreover, they are given a fixed set of problems to solve, which squelches creativity.</p>

<p>Code Pong, as I am imagining it, may not even be possible. Layer Tennis, to use music as metaphor, is more like improvisational performance, whereas programming is more like composition, where short bursts in the psychological state of flow yield more modest fruit. Still, it might be interesting to try.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ettàwîl Cüţx]]></title>
    <link href="http://pohl.github.io/blog/2014/07/12/ettawil-cutx/"/>
    <updated>2014-07-12T21:00:08-05:00</updated>
    <id>http://pohl.github.io/blog/2014/07/12/ettawil-cutx</id>
    <content type="html"><![CDATA[<p>I don&rsquo;t speak <a href="http://en.wikipedia.org/wiki/Ithkuil">Ithkuil</a>, but the title may be equivalent to &ldquo;Hello, World&rdquo;.</p>

<p>I&rsquo;m guessing <a href="http://www.rust-lang.org">Rust</a> will be more approachable. Thankfully I can defer wrapping my head around the syntax for lifetimes.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>fn main() {
</span><span class='line'>    println!("Ettàwîl Cüţx");
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
</feed>
